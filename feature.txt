---
- name: Bond two interfaces and revert if it fails to ping the gateway
  hosts: all
  become: yes
  gather_facts: yes

  tasks:
    - name: Get the primary interface from facts
      set_fact:
        primary_interface: "{{ ansible_default_ipv4.interface }}"
    
    - name: Gather network interfaces for the host
      ansible.builtin.debug:
        var: ansible_facts['ansible_interfaces']
    
    - name: Check if primary interface has VLAN
      shell: "ip -o link show | grep '{{ primary_interface }}' | grep -c '\.'"
      register: vlan_check
      changed_when: False

    - name: Set VLAN tag fact if a VLAN is present
      set_fact:
        vlan_tag: "{{ primary_interface.split('.')[1] }}"
      when: vlan_check.stdout | int > 0

    - name: Find the secondary interface (assume it's the next available interface)
      set_fact:
        secondary_interface: "{{ ansible_facts['ansible_interfaces'] | difference([primary_interface]) | first }}"

    - name: Create bond interface with mode LACP or active-backup
      nmcli:
        conn_name: "bond0"
        ifname: "bond0"
        type: "bond"
        mode: "{{ bond_mode }}"
        ip4: "{{ ansible_default_ipv4.address }}/{{ ansible_default_ipv4.network }}"
        gw4: "{{ ansible_default_ipv4.gateway }}"
        state: up
      vars:
        bond_mode: lacp   # Set to either 'lacp' or 'active-backup'
      notify: restart network

    - name: Add primary interface to bond
      nmcli:
        conn_name: "{{ primary_interface }}-bond"
        ifname: "{{ primary_interface }}"
        master: bond0
        state: up

    - name: Add secondary interface to bond
      nmcli:
        conn_name: "{{ secondary_interface }}-bond"
        ifname: "{{ secondary_interface }}"
        master: bond0
        state: up

    - name: Check if VLAN needs to be bonded
      when: vlan_check.stdout | int > 0
      block:
        - name: Create VLAN on bond
          nmcli:
            conn_name: "bond0.{{ vlan_tag }}"
            ifname: "bond0.{{ vlan_tag }}"
            type: vlan
            vlan_id: "{{ vlan_tag }}"
            state: up

    - name: Test bond by pinging the gateway
      ansible.builtin.ping:
        count: 5
        dest: "{{ ansible_default_ipv4.gateway }}"
      register: ping_result
      ignore_errors: yes

    - name: Revert bond if ping fails
      when: ping_result is failed
      block:
        - name: Remove bond
          nmcli:
            conn_name: "bond0"
            state: absent
        
        - name: Remove VLAN on bond (if present)
          when: vlan_check.stdout | int > 0
          nmcli:
            conn_name: "bond0.{{ vlan_tag }}"
            state: absent

        - name: Restore original network connections
          nmcli:
            conn_name: "{{ primary_interface }}"
            state: up

        - name: Restore secondary interface
          nmcli:
            conn_name: "{{ secondary_interface }}"
            state: up

  handlers:
    - name: Restart network
      service:
        name: NetworkManager
        state: restarted



<INSTALL>
lang en_US
<KEYBOARD>
timezone America/Chicago
rootpw --iscrypted $1$Cr77L9On$4ih6z6vnhn72P4j7LJvyo0 
reboot --eject
text
selinux --disabled
firewall --disabled
skipx
firstboot --disable
auth --enableshadow --passalgo=sha512
<REPO_URL>
bootloader --location=mbr --append="nofb quiet splash=quiet"
%include /var/log/diskpart.cfg
%packages --ignoremissing
@base
bind
bind-chroot
device-mapper-multipath
chrony
cpp
deltarpm
dmidecode
expect
ftp
gcc
glibc-devel
glibc-headers
iotop
iptraf
kernel-devel
kernel-headers
ksh
libstdc++
libstdc++-devel
lm_sensors
lsscsi
mailx
mutt
net-snmp
net-snmp-libs
nfs-utils
nscd
nss-pam-ldapd
ntp
openldap-clients
openmotif
screen
sg3_utils
smartmontools
strace
sysfsutils
sysstat
system-config-kdump
telnet
vsftpd
wget
xinetd
yum
dhclient
git
net-tools
lldpad
redhat-lsb-core
jq
%end
###
### PRE KICKSTART SECTION
###
%pre --interpreter=/usr/libexec/platform-python --log=/var/log/kickstart-python-pre.log
print('this is just to test python interpreter in pre')
%end
%pre --interpreter=/bin/bash --log=/var/log/kickstart-pre.log
echo "*** Pre kickstart starting ***"
IP="<IP>"
NETMASK="<NETMASK>"
GATEWAY="<GATEWAY>"
CIDR="<CIDR>"
VLAN="<VLAN>"
RHEL_RELEASE="<OS_VER>"
RHEL_VER=$(echo ${RHEL_RELEASE}|cut -d'.' -f1)
HARDWARE="<HARDWARE>"
if [[ -z ${HARDWARE} ]]; then
    HARDWARE=$(dmidecode -s system-manufacturer|awk '{print tolower($0)}')
fi
echo "RHEL ${RHEL_VER} and ${RHEL_RELEASE}"
load_rpm () {
    echo "Install racadm or ilorest binary from iso"
    cd /run/install/repo/prekickstart
    for i in $(ls -1 *.rpm) ;do
        echo "Installing ${i} ..."
        rpm -ivUh --nodeps ${i}
        echo "Checking ${i} ..."
        RPM_CHK=$(echo ${i}|sed 's/\.rpm$//')
        rpm -q ${RPM_CHK}
        if [[ $? != 0 ]] ; then
            echo " - FAIL, ${i} failed to install. (exit code: $? )"
            exit 1
        else
            echo " - PASS, ${HARDWARE} rpm installed successfully"
            if [[ ${HARDWARE} != "dell" ]]; then
                LOG_TO_LOM='/usr/sbin/ilorest serverlogs --selectlog=IML -m'
            else    
                LOG_TO_LOM='/opt/dell/srvadmin/sbin/racadm lclog worknote add -m'
            fi
        fi    
    done
}
remove_rootvg () {
    echo "Removing rootvg"
    # activate volumes
    vgchange -ay
    # check for the existence of rootvg
    VG=$(vgs --noheadings | grep rootvg | awk '{ print $1 }')
    # if rootvg exists, then proceed with removing the vg and pv, otherwise skip
    if [ "${VG}" == "rootvg" ]; then
        PV=$(pvs --noheadings | grep rootvg | awk '{ print $1 }')
        vgremove -f -y rootvg
        pvremove -f -y ${PV}
    fi
}
check_interface() {
    local IFACE=$1
    echo "Teting interface ${IFACE} ..."
    echo "#Bring down interface ${IFACE}"
    ip link set ${IFACE} down
    echo "#Assign ip to ${IFACE}" 
    if [[  -z ${VLAN} ]]; then
        echo "NO VLAN FOUND"
        ip link set ${IFACE} down
        ip addr add <IP>/<CIDR> dev ${IFACE}
        ip link set ${IFACE} up
        ip route add default via <GATEWAY>
    else
        echo "VLAN <VLAN> FOUND"  
        local VLAN_IFACE="${IFACE}.<VLAN>"
        ip link set ${IFACE} down
        ip link add link ${IFACE} name $VLAN_IFACE type vlan id <VLAN>
        ip link set $VLAN_IFACE up
        ip addr add <IP>/<CIDR> dev $VLAN_IFACE
        ip link set ${IFACE} up
        ip route add default via <GATEWAY> dev $VLAN_IFACE
    fi
    
    echo "#Test connectivity"
    test_gateway ${IFACE}
    if [[ $? != 0 ]]; then
        echo "Interface ${IFACE} is NOT working"
        if [[ -z ${VLAN} ]]; then
            ip addr del <IP>/<CIDR> dev ${IFACE}
            ip route del default via <GATEWAY>
        else
            ip addr del <IP>/<CIDR> dev $VLAN_IFACE
            ip link set $VLAN_IFACE down
            ip link delete $VLAN_IFACE
            ip route del default via <GATEWAY>
        fi 
        return 1           
    fi
}
test_gateway () {
    local IFACE=$1
    echo "Testing default gateway"
    ping -c 3 <GATEWAY> >/dev/null
    if [[ $? == 0 ]]; then
        echo " - PASS, sending IML"
        ${LOG_TO_LOM} 'ZTP:KS:Pre_primary_network_check_PASS'
        return 0
    else
        echo "- FAIL, Network test FAILED for ${IFACE}."
        MSG="ZTP:KS:INFO: Network test FAILED for ${IFACE}."
        ${LOG_TO_LOM} "${MSG}"
        return 1
    fi
}
find_nic() {
    IFACE=$(ip -br link|awk '{IGNORECASE=1}/<MAC>/{print $1}'|sort -u)
    if [[ -z ${IFACE} ]]; then
        echo "- FAIL,  Unable to get the interface with MAC <MAC> ..."
    fi
    check_interface ${IFACE}
    if [[ $? != 1 ]]; then
        echo "config INTERFACE ${IFACE}"
        cat <<  EOF > /tmp/network-ks.cfg
network --device=${IFACE} --bootproto static --ip=<IP> --netmask=<NETMASK> --gateway=<GATEWAY> --nameserver=<DNS1>,<DNS2> --hostname=<SERVERNAME> --vlanid='<VLAN>' --activate
EOF
    else
        NICS=$(ls /sys/class/net|grep -Ev "lo|${IFACE}")
        MSG="ZTP:KS:WARNING: Primary ${IFACE} failed. Checking interfaces ${NICS}"
        ${LOG_TO_LOM} "${MSG}"
        for i in ${NICS}; do
            echo "FOR LOOP CODE CHECK on ${i}"
                sleep 5
                check_interface ${i}
                if [[ $? != 1 ]]; then
                    MSG="ZTP:KS:WARNING: NON standard Interface ${IFACE} is working!"
                    cat <<  EOF > /tmp/network-ks.cfg
network --device=${IFACE} --bootproto static --ip=<IP> --netmask=<NETMASK> --gateway=<GATEWAY> --nameserver=<DNS1>,<DNS2> --hostname=<SERVERNAME> --vlanid='<VLAN>' --activate
EOF
                    break
                fi    
        done
        ${LOG_TO_LOM} 'ZTP:KS:Pre_primary_network_check_FAIL'
        exit 1
    fi
}
load_rpm
${LOG_TO_LOM} 'ZTP:KS:START============================================ZTP:KS:START'
remove_rootvg
find_nic
LDISK_ID=""
if [[ ${HARDWARE} != "dell" ]]; then
    if [[ -z ${LDISK_ID} ]]; then
        LDISK_ID=$(/usr/sbin/ilorest serverlogs --selectlog=IML|awk -F':' '/LD_ID/{print $NF}')
    fi    
    echo "Setting up boot drive and partition table disk ID = ${LDISK_ID}"
fi
${LOG_TO_LOM} 'ZTP:KS:INFO: Setting up boot drive and partition table'
## 8-17-2023 Deploy only will use the lsblk method today, plan on update soon.
if [[ -z "${LDISK_ID}" ]]; then
    #ROOTVGDISK=$(lsblk |awk '/G/ && /disk/ && ($4 < 900) {print$1}'|head -1)
    #ROOTVGDISK=$(lsblk -b -d -o NAME,SIZE,TYPE|grep -w disk|sort -k2 -n|head -n 1|awk '{print $1}')
    ROOTVGDISK=$(lsblk -b -d -o NAME,SIZE,TYPE|grep ^sd|sort -k2 -n|head -n 1|awk '{print $1}')
    MSG="ZTP:KS:INFO: Using ${ROOTVGDISK} for OS disk from OS lsblk!"
    ${LOG_TO_LOM} "${MSG}"
else    
    ROOTVGDISK=$(ls -lF /dev/disk/by-id/|grep -i ${LDISK_ID}|awk -F'/' '/wwn-/{print $NF}')
    MSG="ZTP:KS:INFO: Using ID ${LDISK_ID} disk name ${ROOTVGDISK} for OS disk from ILO!"
    ${LOG_TO_LOM} "${MSG}"
fi
echo "zerombr" >> /var/log/diskpart.cfg
echo "clearpart --drives=${ROOTVGDISK} --all --initlabel" >> /var/log/diskpart.cfg
echo "part /boot --fstype xfs --size=1024 --ondisk=${ROOTVGDISK}" >> /var/log/diskpart.cfg
if [[ -d /sys/firmware/efi ]]; then
    echo "part /boot/efi --fstype=efi --size=100  --ondisk=${ROOTVGDISK}" >> /var/log/diskpart.cfg
fi
echo "part pv.2 --fstype xfs --size=1024 --grow --ondisk=${ROOTVGDISK}" >> /var/log/diskpart.cfg
echo "volgroup rootvg --pesize=32768 pv.2" >> /var/log/diskpart.cfg
echo "logvol / --fstype=xfs --name=lv_root  --vgname=rootvg --size=10240" >> /var/log/diskpart.cfg
echo "logvol /home --fstype=xfs --name=lv_home --vgname=rootvg --size=1024" >> /var/log/diskpart.cfg
echo "logvol /opt --fstype=xfs --name=lv_opt --vgname=rootvg --size=2048" >> /var/log/diskpart.cfg
echo "logvol /var --fstype=xfs --name=lv_var  --vgname=rootvg --size=8192" >> /var/log/diskpart.cfg
echo "logvol /var/log --fstype=xfs --name=lv_var_log --vgname=rootvg --size=20480" >> /var/log/diskpart.cfg
echo "logvol /var/log/audit --fstype=xfs --name=lv_var_log_audit --vgname=rootvg --size=512" >> /var/log/diskpart.cfg
echo "logvol /var/opt/perf --fstype=xfs --name=lv_var_opt_perf  --vgname=rootvg --size=2048" >> /var/log/diskpart.cfg
echo "logvol /var/core --fstype=xfs --name=lv_var_core --vgname=rootvg --size=1024" >> /var/log/diskpart.cfg
echo "logvol /var/crash --fstype=xfs --name=lv_var_crash --vgname=rootvg --size=3072" >> /var/log/diskpart.cfg
echo "logvol /var/chef --fstype=xfs --name=lv_var_chef --vgname=rootvg --size=1024" >> /var/log/diskpart.cfg
echo "logvol /tmp --fstype=xfs --name=lv_tmp --vgname=rootvg --size=4096" >> /var/log/diskpart.cfg
echo "logvol /monitor --fstype=xfs --name=lv_monitor --vgname=rootvg --size=10240" >> /var/log/diskpart.cfg
cat /var/log/diskpart.cfg
%end
%include /tmp/network-ks.cfg
###
### POST KICKSTART SECTION
###
### post section 1/2
%post --nochroot 
echo "Starting anaconda postinstall"
/bin/cp -rvf /var/log/kickstart-pre.log /mnt/sysimage/var/log/
/bin/cp -rvf /var/log/kickstart-python-pre.log /mnt/sysimage/var/log/
/bin/cp -rvf /var/log/diskpart.cfg /mnt/sysimage/var/log/
/bin/cp -va /etc/resolv.conf /mnt/sysimage/etc/resolv.conf
# copy build.json
/bin/cp -va /run/install/repo/build.json /mnt/sysimage/root/
/bin/mkdir -p /mnt/sysimage/root/rpms/
/bin/cp -va /run/install/repo/prekickstart/*.rpm /mnt/sysimage/root/rpms/
/bin/mkdir -p /mnt/sysimage/root/postbuild
/bin/cp -va /run/install/repo/prekickstart/*.sh /mnt/sysimage/root/postbuild/
%end
### post section 2/2
%post --interpreter=/bin/bash --log=/var/log/kickstart-post.log 
echo "STARTING POSTBUILD"
HARDWARE="<HARDWARE>"
if [[ -z ${HARDWARE} ]]; then
    HARDWARE=$(dmidecode -s system-manufacturer|awk '{print tolower($0)}')
fi
if [[ ${HARDWARE} != "dell" ]]; then
    LOG_TO_LOM='/usr/sbin/ilorest serverlogs --selectlog=IML -m'
else    
    LOG_TO_LOM='/opt/dell/srvadmin/sbin/racadm lclog worknote add -m'
fi
    # install rpm
for file in $(ls /root/rpms/*.rpm); do
    rpm -ivh --nodeps ${file}
done
${LOG_TO_LOM} 'ZTP:KS:INFO: Creating /root/BUILD_ME trigger'
/bin/touch /root/BUILD_ME
${LOG_TO_LOM} 'ZTP:KS:INFO: Creating rc.local'
cat /root/postbuild/firstboot.sh >> /etc/rc.d/rc.local
chmod +x /etc/rc.d/rc.local
${LOG_TO_LOM} 'ZTP:KS:Postkickstart_completed'
${LOG_TO_LOM} 'ZTP:KS:END============================================ZTP:KS:END'
sync
sync
sync
echo "End post kickstart"
%end
